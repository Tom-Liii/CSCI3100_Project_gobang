<!DOCTYPE html>

<head>
    <meta charset="utf-8" />
    <title>bigBang</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://assets.mockflow.com/app/wireframepro/company/C60e51ff3180b4980a08450701f20806b/projects/M84VLDquVob/images/M21e210354201a0e956ded9da48a82c021679583773900">
    <script src="./scripts/aiFunctions.js"></script>
    <style>
      body {
        background-color: #ffe7cc;
      }

      

      #timer-display {
        font-size: 2em;
        text-align: center;
        margin-top: 20px;
      }

      #player-icon {
      width: 50px;
      height: 50px;
      background-image: url("http://34.225.43.131/images/user.png");
      background-repeat: no-repeat;
      background-size: contain;}
      

      #black {
        fill: radial-gradient(circle, #808080, #111);
      }
  
      #white {
        fill: radial-gradient(circle, #fff, #ddd);
      }
      
      #game-result {
        font-family: 'Space Grotesk', sans-serif;
        line-height: 0.7em;
      }

      .hidden {
        display: none;
      }
      
      #floating-window {
        position: fixed;
        height: 500px;
        width: 600px;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 100;
      }

      .question{
        height: 32px;
        width: 32px;
      }

      .window-content {
        margin-top: 10px;
      }

    </style>


<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500&display=swap');
</style>
  
  
</head>



<body style="height: 100%; margin: 0">


    <svg id="board" viewBox="-95,-95,190,190" style="position: fixed; top: 100; left: 160; height: 570; width: 570" xmlns="http://www.w3.org/2000/svg">
        <defs>

          <radialGradient id="black">
            <stop offset="0%" style="stop-color:#434141" />
            <stop offset="100%" style="stop-color:#111" />
          </radialGradient>

          <radialGradient id="white">
            <stop offset="0%" style="stop-color:#ffffff" />
            <stop offset="100%" style="stop-color:#ede7e7" />
          </radialGradient>

          <circle id="mark" r="1.3"/>
          <circle id="piece" r="4.2"/>
        </defs>
        <path stroke="black" stroke-width="0.5" fill="none" d="m-90,-90h180v180h-180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180
        zm10,0v180zm10,0v180zm10,0v180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180
        zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180"/>
        <use xlink:href="#mark"/>
        <use xlink:href="#mark" x="60" y="60"/>
        <use xlink:href="#mark" x="60" y="-60"/>
        <use xlink:href="#mark" x="-60" y="60"/>
        <use xlink:href="#mark" x="-60" y="-60"/>
        <use xlink:href="#mark" x="0" y="60"/>
        <use xlink:href="#mark" x="0" y="-60"/>
        <use xlink:href="#mark" x="60" y="0"/>
        <use xlink:href="#mark" x="-60" y="0"/>
      </svg>
      <!-- This part is used to draw the Goboard-->
      
 

      
      <svg id="left-timer-icon" width="45" height="45" style="position: fixed; top: 230px; left: 895px; ">
        <circle id="black-timer-circle" cx="22.5" cy="22.5" r="16" stroke="#7b6801" stroke-width="5.4" fill="none"/>
        <line id="black-timer-line1" x1="22.5" y1="22.5" x2="22.5" y2="11.5" stroke="#7b6801" stroke-width="2.8"/>
        <line id="black-timer-line2" x1="23.75" y1="22.5" x2="13.5" y2="22.5" stroke="#7b6801" stroke-width="2.8"/>
      </svg>
      <p id="timer-blackdisplay" style="position: fixed; top: 206px; left: 950px ;font-size: 28px; font-family: 'Space Grotesk', sans-serif;; font-weight: 500; color: #7b6801;"></p>
  
      <svg id="right-timer-icon" width="45" height="45" style="position: fixed; top: 230px; left: 1145px; ">
        <circle id="white-timer-circle" cx="22.5" cy="22.5" r="16" stroke="#7b6801" stroke-width="5.4" fill="none"/>
        <line id="white-timer-line1" x1="22.5" y1="22.5" x2="22.5" y2="11.5" stroke="#7b6801" stroke-width="2.8"/>
        <line id="white-timer-line2" x1="23.75" y1="22.5" x2="13.5" y2="22.5" stroke="#7b6801" stroke-width="2.8"/>
      </svg>
      <p id="timer-whitedisplay" style="position: fixed; top: 206px; left: 1200px;font-size: 28px; font-family: 'Space Grotesk', sans-serif;; font-weight: 500; color: #7b6801;"></p>
    
      <!-- This part is to display the timer-->

      
      
      
    <div style="position: fixed; top: 310px; left: 950px;" id="player-icon"></div>
    <svg style="position: fixed; top: 286px; left: 921.5px; height: 100; width: 100" viewBox="0 0 60 60">
      <circle cx="30" cy="30" r="20" fill="transparent" stroke="#7b6801" stroke-width="1.6"/>
    </svg>

    <div style="position: fixed; top: 310px; left: 1200px;" id="player-icon"></div>
    <svg style="position: fixed; top: 286px; left: 1171.5px; height: 100; width: 100" viewBox="0 0 60 60">
      <circle cx="30" cy="30" r="20" fill="transparent" stroke="#7b6801" stroke-width="1.6"/>
    </svg>
    <!-- This part is to display the player icon-->
    
    <div id="vs" style="position: fixed; top: 310px; left: 1075px; font-size: 28px; font-family: 'Space Grotesk', sans-serif; font-weight: 500; color: #7b6801;">
      <span style="padding-right: 10px;">vs</span>
    </div>
    
    <div id="game-result" style="position: fixed; top: 430px; left: 1015px; font-size: 30px; font-family: 'Space Grotesk', sans-serif; font-weight: 500; color: brown; text-align: center;"></div>   
     
    <img id="undo-button" src="http://34.225.43.131/images/back.png" style="position: fixed; top: 65px; left: 670px; width: 32px; height: 32px; cursor: pointer;"/>

    <button id="surrender-button" style="position: fixed; top: 500px; left: 995px; font-size: 18px; font-family: 'Space Grotesk', sans-serif; background-color: #c32c20; color: white; border: none; padding: 10px 60px; border-radius: 5px; text-align: center; cursor: pointer;">Surrender</button>

    <button id="exchange-button" style="position: fixed; top: 580px; left: 995px; font-size: 18px; font-family: 'Space Grotesk', sans-serif; background-color: #7b6801; color: white; border: none; padding: 10px 60px; border-radius: 5px; text-align: center; cursor: pointer;">Exchange</button>



    <button id="open-window-button" class= "question" style="position: fixed; top: 28px; left: 1370px; background: none; border: none; padding: 0; cursor: pointer;">
      <img class= "question" src="http://34.225.43.131/images/question.png" alt="Open Floating Window">
    </button>
    
    <div id="floating-window" class="hidden">
      <button id="close-window-button">Close Floating Window</button>
      <div class="window-content">
        <p>This is the content of the floating window.</p>
      </div>
    </div>

    <div id="help" style="position: fixed; top: 25px; left: 1300px; font-size: 28px; font-family: 'Space Grotesk', sans-serif; font-weight: 500; color: #7b6801;">
      <span style="padding-right: 10px;" alt="Open Floating Window">Help</span>
    </div>

    

    <script>
     
     
     document.getElementById('open-window-button').addEventListener('click', function() {
      document.getElementById('floating-window').classList.remove('hidden');
    });
    
    document.getElementById('close-window-button').addEventListener('click', function() {
      document.getElementById('floating-window').classList.add('hidden');
    });
     

     class Timer {
      constructor(timeInSeconds) {
        this.totalTime = timeInSeconds;
        this.remainingTime = timeInSeconds;
        this.interval = null;
      }

      start(updateCallback) {
        this.interval = setInterval(() => {
          this.update();
          if (updateCallback) {
            updateCallback();
          }
        }, 1000);
      }
        
      stop() {
        clearInterval(this.interval);
      }
      
      reset() {
        this.remainingTime = this.totalTime;
      }

      update() {
        if (this.remainingTime > 0) {
          this.remainingTime -= 1;
        } else {
          this.stop();
        }
      }


      getFormattedTime() {
        const minutes = Math.floor(this.remainingTime / 60);
        const seconds = this.remainingTime % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }
    
      isTimeOut() {
        return this.remainingTime <= 0;
      }
    
    }
    // This is the structure of Timer

    
    class GameSettings {
      constructor(gameMode, earlyTermination, threeStepExchange, fiveStepThreeStrikes, timerStatus, timerTime) {
        this.gameMode = gameMode;
        this.earlyTermination = earlyTermination;
        this.threeStepExchange = threeStepExchange;
        this.fiveStepThreeStrikes = fiveStepThreeStrikes;
        this.timerStatus = timerStatus;
        this.timerTime = timerTime;
        this.player1Timer = new Timer(timerTime);
        this.player2Timer = new Timer(timerTime);
      }
    }
    // This is the structure of game settings, and it is used to store game settings information


    class RoomInfor{
        roomNum = null;
        isVisitor = false;
        isReady = false;
        isBlack = false;
        iniColor = 1;
      }


      let gameSettings = null;
      let boardStatus = null;
      let ws = null;
      let roomInfor = new RoomInfor();
      let playerColor = 1; // The initial color is black
      let anotherDropped = 0;
      let anotherMovement = [];
      let gameStopped = false; // Set gameStopped to false as default
      let exchanged = false; // Set exchanged to false as default
      let player = 1;

      let count = 1; // Count used to count the turn
      let countBlack = 0;

      function initializeGame(gameMode, userID, roomNum, isEarlyTermValid, isThreeExchangeValid, isFiveThreeHitValid,isTimeValid, maxTimeSet) {
        //gameSettings = new GameSettings(gameMode, true, true, false, true, 300);

        gameSettings = new GameSettings(gameMode, isEarlyTermValid, isThreeExchangeValid, isFiveThreeHitValid,isTimeValid, maxTimeSet);
        boardStatus = new Array(19).fill().map(() => new Array(19).fill(0));
        
        if(gameMode == "PVP"){

          ws = new WebSocket(`ws://${window.location.host}`);

          ws.onopen = () => {
            console.log('onopen');
            ws.send(JSON.stringify({type: 'EnterRoom', id: userID, room: roomNum}));
          };

          ws.onclose = function(event){
            console.log("onClose");
            if (event.code !== 1000) {
              if (event.code === 4000) {
                window.alert('您已在新的浏览器窗口中进入了该房间，本页面将转换为单机模式！');
              } else {
                window.alert('连接已断开，将转换为单机模式！');
              }
              setOffline();
            }
          }

          
          ws.onmessage = function (ev){
            //console.log('onmessage');
            const data = JSON.parse(ev.data);
            const type = data['type'];

            if (type === 'InitializeRoomState') {
              console.log('onInitializeRoomState');
              roomInfor.isVisitor = data.visiting;
              roomInfor.isBlack = data.isBlack;
              //boardStatus = data.boardStatus;
              roomInfor.isReady = data.ready;

              if (!roomInfor.isVisitor) {
                if(roomInfor.isReady){
                  if(!roomInfor.isBlack){
                    roomInfor.iniColor = -1;
                    alert('欢迎,您执白棋');
                  }
                }
                else alert(`欢迎，等待对手中。`);
              }
              else {
              alert('游戏禁止观战');
              window.open("about:blank","_self").close();
              }
            }

            else if(type === 'AddPlayer'){
              console.log('onAddPlayer');
              if (!roomInfor.isVisitor && data.ready && roomInfor.isBlack === true) {
                roomInfor.isReady = true;
                window.alert('您执黑棋，下棋后即开局，无法更换黑白和对手。');
              }
            }

            else if(type === 'DropPiece'){
              console.log('onDropPiece');
              boardStatus = data.boardStatus;
              displayGoboard();
              //anotherMovement = data.movement;
              anotherDropped = 1;
              
            }

            else if (type === 'GameOver') {
              winStatus = data.winner;
              
              if (winStatus != 0){
                gameStopped = true;
              }
              /*const gameResult = document.getElementById("game-result");
              
              if (winner === 1) {
                gameResult.innerHTML = "Game Over! Black wins!";
              } else if (winner === -1) {
                gameResult.innerHTML = "Game Over! White wins!";
              }*/
              //gameStopped = true;
            }
/*******************************************************************************************************************/
            else if (type === 'TimeSet') {
              //console.log('onTimeSet, Get Time');
              gameSettings.player1Timer.remainingTime = data.p1Time;
              gameSettings.player2Timer.remainingTime = data.p2Time;
            }
            else if (type ==='ThreeChange'){
                console.log('onThreeChange')
                roomInfor.iniColor = (-1) * roomInfor.iniColor;
                exchanged = true; 
                player = 1;
                count = 7;
                gameSettings.player2Timer.stop();
                gameSettings.player1Timer.start();  
                
            }

            else{
              console.log('on ELSE message');
            }
/*******************************************************************************************************************/
            

        }
      }
    }
      
      
      initializeGame("PVP", Math.floor(100*Math.random()), 1, false, true, false, true, 65);

 

    let previousBoard = [boardStatus,boardStatus,boardStatus];
    let undoCount = -1;
    
    // Setting game mode, and create a new empty board
      

    const lefttimerIcon = document.getElementById('left-timer-icon');
    const righttimerIcon = document.getElementById('right-timer-icon');

    if (gameSettings.timerStatus && gameSettings.gameMode == "PVP") {
      lefttimerIcon.style.display = 'block';
      righttimerIcon.style.display = 'block';
    } else {
      lefttimerIcon.style.display = 'none';
      righttimerIcon.style.display = 'none';
    }
    // Display the timer icons only when the timer is enabled

    
    async function play() {
      if (count == 1){
        await delay(5000);
      }
      
      
      let winStatus = 0; // Define winStatus, it is 0 when there is no winner.

   

  
      if (gameSettings.gameMode === 'PVP' && gameSettings.timerStatus) {
        checkTimeOut(); // Call the checkTimeOut() function after starting the timers
      }
      
      const timerBlackDisplay = document.getElementById('timer-blackdisplay');
      const timerWhiteDisplay = document.getElementById('timer-whitedisplay');
      
      const exchangeButton = document.getElementById("exchange-button");
      exchangeButton.addEventListener('click', () => {
                // Perform exchange functionality here
                exchanged = true; 
                player = 1;
                count = 7;
                gameSettings.player2Timer.stop();
                gameSettings.player1Timer.start();  
                undoButton.style.display = "none";     
/*******************************************************************************************************************/
                gameSettings.iniColor = (-1) * gameSettings.iniColor;
                ws.send(JSON.stringify({ type: 'ThreeChange', exchanged: exchanged}));

/*******************************************************************************************************************/
              });
      exchangeButton.style.display = "none";

      setInterval(() => {
        if (gameSettings.gameMode === 'PVP' && gameSettings.timerStatus) {
/*******************************************************************************************************************/
        if(playerColor == roomInfor.iniColor)
          ws.send(JSON.stringify({ type: 'TimeSet', p1Time: gameSettings.player1Timer.remainingTime, p2Time: gameSettings.player2Timer.remainingTime}));

/*******************************************************************************************************************/
          const player1TimerCircle = document.getElementById('black-timer-circle');
          const player1TimerLine1 = document.getElementById('black-timer-line1');
          const player1TimerLine2 = document.getElementById('black-timer-line2');
          const player2TimerCircle = document.getElementById('white-timer-circle');
          const player2TimerLine1 = document.getElementById('white-timer-line1');
          const player2TimerLine2 = document.getElementById('white-timer-line2');
          if (playerColor === 1) {
            let remainingTime = gameSettings.player1Timer.remainingTime;
            timerBlackDisplay.innerHTML = `${gameSettings.player1Timer.getFormattedTime()}`;
            if (remainingTime <= 60) {
              timerBlackDisplay.style.color = '#c32c20';
              document.getElementById('left-timer-icon').setAttribute('stroke', '#c32c20'); // set stroke color of left timer icon to red
              player1TimerCircle.setAttribute('stroke', '#c32c20');
              player1TimerLine1.setAttribute('stroke', '#c32c20');
              player1TimerLine2.setAttribute('stroke', '#c32c20');
            } else {
              timerBlackDisplay.style.color = '#7b6801';
            }
            timerWhiteDisplay.innerHTML = `${gameSettings.player2Timer.getFormattedTime()}`;
            } 
            else {
              let remainingTime = gameSettings.player2Timer.remainingTime;
              timerBlackDisplay.innerHTML = `${gameSettings.player1Timer.getFormattedTime()}`;
              timerWhiteDisplay.innerHTML = `${gameSettings.player2Timer.getFormattedTime()}`;
              if (remainingTime <= 60) {
                timerWhiteDisplay.style.color = '#c32c20';
                document.getElementById('right-timer-icon').setAttribute('stroke', '#c32c20'); // set stroke color of right timer icon to red
                player2TimerCircle.setAttribute('stroke', '#c32c20');
                player2TimerLine1.setAttribute('stroke', '#c32c20');
                player2TimerLine2.setAttribute('stroke', '#c32c20');
              } else {
                timerWhiteDisplay.style.color = '#7b6801';
              }
            }
        }
      }, 20);
      // Display the black timer and white timer time continuously, and when the time is less than a minute, display the time in red

      const undoButton = document.getElementById("undo-button");
      undoButton.addEventListener('click', () => {
      // Perform undo functionality here
        undoMove(); 
        if (count!= 6) exchangeButton.style.display = "none";
        });




        while (winStatus == 0) {

          if (gameStopped) {
            break;
          }

 

          if (undoCount >= 2 && gameSettings.gameMode == "PVP") {
              undoButton.style.display = 'block';
            } 
            else{
              undoButton.style.display = 'none';
            }
          // Hide the undo button if from last undo/ beginning <2


          if ((gameSettings.gameMode === 'PVP' && gameSettings.timerStatus)&&(count!= 1)) {
            if (player == 1) {
              gameSettings.player2Timer.stop();
              gameSettings.player1Timer.start();
            } else {       
              gameSettings.player1Timer.stop();       
              gameSettings.player2Timer.start();
            }
          }

          let validStatus = 0;
          let validMovement;
          let movement
          
          const surrenderButton = document.getElementById('surrender-button');
          
          
          surrenderButton.addEventListener('click', () => {
            console.log("1111111");
            surrenderButton.style.display = 'none';
            if (player === 1) {
              gameStopped = true;
              winStatus = 2; // player 2 wins
            } else {
              gameStopped = true;
              winStatus = 1; // player 1 wins
            }
          // Call the function to end the game and display the result
        });

          while (validStatus == 0) {
            if (gameStopped) {
              gameSettings.player1Timer.stop();
              gameSettings.player2Timer.stop();
              // If the game is stopped due to a timeout, break out of the loop
              break;
            }

            if (exchanged) {
              exchanged = false;

            }

            if ((gameSettings.gameMode == "Random")&&(playerColor == -1)) {
              // Generate a random movement 
              const x = Math.floor(Math.random() * 19);
              const y = Math.floor(Math.random() * 19);
              movement = [x, y];}
            else if ((gameSettings.gameMode == "Medium")&&(playerColor == -1)){
              movement = mediumAI(boardStatus);
            }
            else if ((gameSettings.gameMode == "Hard")&&(playerColor == -1)){
              movement = expertAI(boardStatus);
            }
            else if ((gameSettings.gameMode == "PVP")&&((gameSettings.fiveStepThreeStrikes) && (countBlack == 4))){
              movement = fiveStepThreeStrikes();
            }
            else if ((gameSettings.gameMode == "PVP")&&((gameSettings.threeStepExchange) && (count == 6) && (roomInfor.iniColor == -1))){
              threeStepExchange();
              movement = await getMovement(playerColor);
              
              exchangeButton.style.display = "none";
              
              //After made a decision, hide the icon
            }

            
            else if (gameSettings.gameMode == "PVP" && playerColor != roomInfor.iniColor) {
              console.log("before while lock");
              console.log('player color print: 18');
              console.log(playerColor); 

              const waitForAnotherDrop = async () => {
                return new Promise((resolve) => {
                  const checkInterval = setInterval(() => {
                    if ((anotherDropped == 1)||(gameStopped)||(exchanged)) {
                      clearInterval(checkInterval);
                      resolve();
                    }
                  }, 100);
                });
              };

              await waitForAnotherDrop();
              console.log("after while lock");
              console.log('player color print: 19');
              console.log(playerColor); 
              anotherDropped = 0;

              break;
            }

            else{
              movement = await getMovement(playerColor);
            }
            if(!((gameSettings.gameMode == "PVP")&&(playerColor != roomInfor.iniColor))){
              //console.log(`Clicked at coordinates: (${movement[0]}, ${movement[1]})`);
              validStatus = isValid(movement);
              console.log('player color print: 20');
              console.log(playerColor); // Corrected typo in console.log
              validMovement = movement;
            }
            else if(!((gameSettings.gameMode == "PVP")&&(playerColor == roomInfor.iniColor)))
            {break;}
            else{
            validStatus = isValid(movement);
            validMovement = movement;
            }
          }
          // The inner game loop, place a piece until the location is valid

          if (gameStopped && checkWin() == 0) {
                break;
          }

          if(!((gameSettings.gameMode == "PVP")&&(playerColor != roomInfor.iniColor))){
            Update(validMovement,playerColor);  
            displayGoboard();
          }

          if ((count == 2)&&(player == 1)){
            gameSettings.player1Timer.start();
            gameSettings.player2Timer.stop();
          }

          console.log(count);
          undoCount++;
          if (playerColor == 1){
            countBlack++;
            console.log(countBlack);
          }
          count++;
          
          previousBoard[0] = JSON.parse(JSON.stringify(previousBoard[1]));
          previousBoard[1] = JSON.parse(JSON.stringify(previousBoard[2]));
          previousBoard[2] = JSON.parse(JSON.stringify(boardStatus));
          // update the previous saved board and add the current boardStatus to record
          

          winStatus = checkWin();
          // Then update and delete the board, check if there is winner


          

          playerColor = -playerColor;
          
          if (player == 1){
            player = 2;
          }
          else{
            player = 1;
          }
          // Switch the player color
          console.log(player);

          if (gameStopped && checkWin() != 0) {
                break;
          }
          
        }
        // The Outer game loop, when there is no winner the game continues

        if (winStatus !== 0) {
          if (gameSettings.gameMode == "PVP") {
            ws.send(
              JSON.stringify({
                type: "GameOver",
                winner: -playerColor, 
              })
            );
          }
        }
        // Send the winner information to the server

        // Stop the timers and update the result
        gameSettings.player1Timer.stop();
        gameSettings.player2Timer.stop();
          

        
        undoButton.style.display = 'none';
        const surrenderButton = document.getElementById("surrender-button");
        surrenderButton.style.display = 'none';
        // When the game ends, hide the undo button and surrender button

        console.log(player);
        if (player == 1){
          winStatus = 2;
        }
        else if (player == 2){
          winStatus = 1;
        }
        // Determine who is the winner

        if (winStatus !== 0 && gameSettings.gameMode === "PVP") {
            ws.send(JSON.stringify({ type: 'GameOver', winner: winStatus }));
          }
          // Send game over message when the game ends
        
        const gameResult = document.getElementById("game-result");
        if (winStatus === 1) {
          gameResult.innerHTML = "Game Over!<br><span style='font-size:16px;'>Player 1 wins!</span>";
        } 
        else if (winStatus === 2) {
          gameResult.innerHTML = "Game Over!<br><span style='font-size:16px;'>Player 2 wins!</span>";
        }
        // Update the game-result element when the game ends
          
      }
      // This part is the script of the game (Main structure)

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      play();



      function isValid(movement) {

        let x = movement[0];
        let y = movement[1];

        if (x > 18 || y > 18) return false;

        if (boardStatus[x][y]!=0){
          return false;
        }
        else{
          return true;
        }
      }
      //This function checks if the move is valid
    
      function displayGoboard() {
        const board = document.getElementById("board");
        // Remove existing pieces from the board
        const existingPieces = document.querySelectorAll(".black, .white");
        existingPieces.forEach((piece) => board.removeChild(piece));
        
        // Iterate through the boardStatus and add pieces to the board
        for (let i = 0; i < 19; i++) {
          for (let j = 0; j < 19; j++) {
            if (boardStatus[i][j] !== 0) {
              const piece = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              piece.setAttribute("r", "4.2");
              piece.setAttribute("cx", (i - 9) * 10);
              piece.setAttribute("cy", (j - 9) * 10); 
              
              piece.setAttribute("fill", boardStatus[i][j] == 1 ? "black" : "white");
              piece.setAttribute("class", boardStatus[i][j] == 1 ? "black" : "white");
              board.appendChild(piece);
            }
          }
        }
      }
      //This function displays the board based on the boardStatus


      function Update(movement,playerColor) {
        let x = movement[0];
        let y = movement[1];
        boardStatus[x][y] = playerColor;

        if(gameSettings.gameMode == "PVP")  
          ws.send(JSON.stringify(  {type: 'DropPiece', boardStatus: boardStatus, movement: movement, turn: playerColor,}  ));

      }
      //This function updates the boardStatus according to new move
    
      function checkWin() {
        const len = boardStatus.length;
        
        function checkLine(x, y, dx, dy) {
          const player = boardStatus[x][y];
          if (player === 0) return false;
          for (let i = 1; i < 5; i++) {
            const newX = x + dx * i;
            const newY = y + dy * i;
            if (
              newX < 0 || newX >= len ||
              newY < 0 || newY >= len ||
              boardStatus[newX][newY] !== player
              ) {
                return false;
              }
            }
            return true;
        }
        for (let i = 0; i < len; i++) {
          for (let j = 0; j < len; j++) {
            if (
              checkLine(i, j, 1, 0) ||
              checkLine(i, j, 0, 1) ||
              checkLine(i, j, 1, 1) ||
              checkLine(i, j, 1, -1)
              ) {
                return boardStatus[i][j];
              }
            }
          }
          return 0;
        }
        // This function will check if there is winner of this game

      function getMovement(playerColor) {
        return Promise.race([
          new Promise((resolve) =>  {
          const board = document.getElementById("board");
          
          const tempPiece = createTempPiece();
          board.appendChild(tempPiece);

          
          board.addEventListener("mousemove", function (event) {
            if (gameStopped||exchanged) {
              tempPiece.setAttribute("cx", -1000);
              tempPiece.setAttribute("cy", -1000);
              return; // If the game is stopped, return immediately and hide the tempPiece
            }

            const rect = board.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            newx = Math.floor(x/30);
            newy = Math.floor(y/30);

            if (boardStatus[newx][newy]== 0){
            tempPiece.setAttribute("cx", (newx-9)*10);
            tempPiece.setAttribute("cy", (newy-9)*10);
            if (playerColor==-1){
              tempPiece.style.opacity = "0.68";
            }
            tempPiece.setAttribute("fill", playerColor == 1 ? "black" : "white");
            }
            
            

          });

          function onClick(event) {
            
            if (gameStopped) {
              return; // If the game is stopped, return immediately without waiting for user input 
            }
            const rect = board.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            board.removeEventListener("click", onClick);
            board.removeChild(tempPiece);

            newx = Math.floor(x/30);
            newy = Math.floor(y/30);
            
            resolve([newx,newy]);
          }
    
          board.addEventListener("click", onClick);
        }),
        
        new Promise((resolve) => {
          const checkInterval = setInterval(() => {
            if (gameStopped||exchanged) {
              clearInterval(checkInterval);
              resolve([100, 100]);
            }
          }, 100);
        }),
      ]);


        function createTempPiece() {
          const piece = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          piece.setAttribute("r", "4.2");
          piece.style.opacity = "0.3";
          piece.setAttribute("cx", -1000);
          piece.setAttribute("cy", -1000);
          return piece;
        }
      }
      // This function will get the position of the mouse on the board, as well as the position to drop the piece


      function checkTimeOut() {
        setInterval(() => {
          if (gameSettings.player1Timer.isTimeOut()) {
            gameStopped = true;
            winStatus = 2;
          } else if (gameSettings.player2Timer.isTimeOut()) {            
            gameStopped = true;
            winStatus = 1;
          }
        }, 1000);
      }


 
      function undoMove() {
        undoCount = 0;
        count = count - 2;
        countBlack = countBlack - 1;
        const undoButton = document.getElementById("undo-button");
        undoButton.style.display = 'none';
        
        boardStatus = JSON.parse(JSON.stringify(previousBoard[0]));
        previousBoard[0] = JSON.parse(JSON.stringify(boardStatus));
        previousBoard[1] = JSON.parse(JSON.stringify(boardStatus));
        previousBoard[2] = JSON.parse(JSON.stringify(boardStatus));
        displayGoboard();
        
      }


      function threeStepExchange(){
        const exchangeButton = document.getElementById("exchange-button");
        exchangeButton.style.display = "block"; 
      }



    </script>



    


</body>