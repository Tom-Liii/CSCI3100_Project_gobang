<!DOCTYPE html>

<head>
    <meta charset="utf-8" />
    <title>bigBang</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://assets.mockflow.com/app/wireframepro/company/C60e51ff3180b4980a08450701f20806b/projects/M84VLDquVob/images/M21e210354201a0e956ded9da48a82c021679583773900">
    <script src="./scripts/aiFunctions.js"></script>
    <style>
      body {
        background-color: #ffe7cc;
      }

      #timer-icon {
      width: 40px;
      height: 40px;
      background-image: url("https://cdn-icons-png.flaticon.com/512/37/37663.png");
      background-repeat: no-repeat;
      background-size: contain;
      cursor: pointer;}

      #timer-display {
        font-size: 2em;
        text-align: center;
        margin-top: 20px;
      }

      #player-icon {
      width: 50px;
      height: 50px;
      background-image: url("images/user.png");
      background-repeat: no-repeat;
      background-size: contain;}
      

      #black {
        fill: radial-gradient(circle, #808080, #111);
      }
  
      #white {
        fill: radial-gradient(circle, #fff, #ddd);
      }
      
      #game-result {
        font-family: 'Space Grotesk', sans-serif;
        color: red;
      }

      


    </style>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500&display=swap');
</style>
  
  
</head>



<body style="height: 100%; margin: 0" onload="countdown()">


    <svg id="board" viewBox="-95,-95,190,190" style="position: fixed; top: 100; left: 160; height: 570; width: 570" xmlns="http://www.w3.org/2000/svg">
        <defs>

          <radialGradient id="black">
            <stop offset="0%" style="stop-color:#434141" />
            <stop offset="100%" style="stop-color:#111" />
          </radialGradient>

          <radialGradient id="white">
            <stop offset="0%" style="stop-color:#ffffff" />
            <stop offset="100%" style="stop-color:#ede7e7" />
          </radialGradient>

          <circle id="mark" r="1.3"/>
          <circle id="piece" r="4.2"/>
        </defs>
        <path stroke="black" stroke-width="0.5" fill="none" d="m-90,-90h180v180h-180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180zm10,0v180
        zm10,0v180zm10,0v180zm10,0v180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180
        zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180zm0,10h-180"/>
        <use xlink:href="#mark"/>
        <use xlink:href="#mark" x="60" y="60"/>
        <use xlink:href="#mark" x="60" y="-60"/>
        <use xlink:href="#mark" x="-60" y="60"/>
        <use xlink:href="#mark" x="-60" y="-60"/>
        <use xlink:href="#mark" x="0" y="60"/>
        <use xlink:href="#mark" x="0" y="-60"/>
        <use xlink:href="#mark" x="60" y="0"/>
        <use xlink:href="#mark" x="-60" y="0"/>
      </svg>
      <!-- This part is used to draw the Goboard-->
      
 
      <svg width="45" height="45" style="position: fixed; top: 230px; left: 895px; ">
        <circle cx="22.5" cy="22.5" r="16" stroke="#7b6801" stroke-width="5.4" fill="none"/>
        <line x1="22.5" y1="22.5" x2="22.5" y2="11.5" stroke="#7b6801" stroke-width="2.8"/>
        <line x1="23.75" y1="22.5" x2="13.5" y2="22.5" stroke="#7b6801" stroke-width="2.8"/>
      </svg>
      <svg width="45" height="45" style="position: fixed; top: 230px; left: 1145px; ">
        <circle cx="22.5" cy="22.5" r="16" stroke="#7b6801" stroke-width="5.4" fill="none"/>
        <line x1="22.5" y1="22.5" x2="22.5" y2="11.5" stroke="#7b6801" stroke-width="2.8"/>
        <line x1="23.75" y1="22.5" x2="13.5" y2="22.5" stroke="#7b6801" stroke-width="2.8"/>
      </svg>
      <!-- This part is to display the timer-->
      
      
      
    <div style="position: fixed; top: 310px; left: 950px;" id="player-icon"></div>
    <svg style="position: fixed; top: 286px; left: 921.5px; height: 100; width: 100" viewBox="0 0 60 60">
      <circle cx="30" cy="30" r="20" fill="transparent" stroke="#7b6801" stroke-width="1.6"/>
    </svg>

    <div style="position: fixed; top: 310px; left: 1200px;" id="player-icon"></div>
    <svg style="position: fixed; top: 286px; left: 1171.5px; height: 100; width: 100" viewBox="0 0 60 60">
      <circle cx="30" cy="30" r="20" fill="transparent" stroke="#7b6801" stroke-width="1.6"/>
    </svg>
    <!-- This part is to display the player icon-->
    
    <div id="vs" style="position: fixed; top: 310px; left: 1075px; font-size: 28px; font-family: 'Space Grotesk', sans-serif; font-weight: 500; color: #7b6801;">
      <span style="padding-right: 10px;">vs</span>
    </div>
    
    <div id="game-result" style="position: fixed; top: 450px; left: 940px; font-size: 28px; font-family: 'Space Grotesk', sans-serif;; font-weight: 500; color: brown;"></div>


    


    <script>
     
    
    class GameSettings {
      constructor(gameMode, earlyTermination, threeStepExchange, fiveStepThreeStrikes, timerStatus, timerTime) {
        this.gameMode = gameMode;
        this.earlyTermination = earlyTermination;
        this.threeStepExchange = threeStepExchange;
        this.fiveStepThreeStrikes = fiveStepThreeStrikes;
        this.timerStatus = timerStatus;
        this.timerTime = timerTime;
      }}

      

/********************************************************************/
  
      const Message = (content) => {
        const div = document.createElement('div');
        div.innerHTML = `<div>${content}</div>`;
        messageDiv.appendChild(div);
        setTimeout(() => messageDiv.removeChild(div), 3000);
      };
  
      
      class RoomInfor{
        roomNum = null;
        blackID = null;
        whiteID = null;
        blackTime = null;
        whiteTime = null;
        isVisitor = false;
        isReady = false;
        isBlack = false;
      }


      let gameSettings = null;
      let boardStatus = null;
      let ws = null;
      let roomInfor = new RoomInfor();

      
      
      function initializeGame(gameMode, userID, roomNum) {
        gameSettings = new GameSettings(gameMode, true, true, false, true, 300);
        boardStatus = new Array(19).fill().map(() => new Array(19).fill(0));
        
        if(gameMode == "PvP"){

          ws = new WebSocket(`ws://${window.location.host}`);
          ws.onopen = function() {
            ws.send(JSON.stringify({type: 'EnterRoom', id: userID, room: roomNum}));
          }

          ws.onclose = function(event){
            if (event.code !== 1000) {
              if (event.code === 4000) {
                alert('您已在新的浏览器窗口中进入了该房间，本页面将转换为单机模式！');
              } else {
                alert('连接已断开，将转换为单机模式！');
              }
              setOffline();
            }
          }

          
          ws.onmessage = function (ev){
            const data = JSON.parse(ev.data);
            const type = data['type'];

            if (type === 'InitializeRoomState') {
              roomInfor.isVisitor = data.visiting;
              roomInfor.isBlack = data.isBlack;
              boardStatus = data.boardStatus;
              room.isReady = data.ready;

              if (!roomInfor.isVisitor) {
                if(roomInfor.isReady){
                  if(isBlack) Message('欢迎,您执黑棋');
                  else Message('欢迎,您执白棋');
                }
                else Message(`欢迎，等待对手中。`);
              }
              else Message('欢迎,观战者');
              
            }

            else if(type === 'AddPlayer'){
              if (!roomInfor.isVisitor && data.ready && roomInfor.isBlack === true) {
                roomInfor.isReady = true;
                Message('您执黑棋，下棋后即开局，无法更换黑白和对手。');
              }
            }

            else if(type === 'DropPiece'){
              boardStatus = data.boardStatus;
            }

        }
      }
    }
      
      
      initializeGame("PvP", 1, 1);
      
/********************************************************************/


      async function play() {
        let winStatus = 0; // Define winStatus
        let playerColor = 1;
        

        while (winStatus == 0) {
          let validStatus = 0;
          let validMovement;
          let movement
          
          while (validStatus == 0) {


            if ((gameSettings.gameMode == "Random")&&(playerColor == -1)) {
              // Generate a random movement 
              const x = Math.floor(Math.random() * 19);
              const y = Math.floor(Math.random() * 19);
              movement = [x, y];}
            else if ((gameSettings.gameMode == "Medium")&&(playerColor == -1)){
              movement = mediumAI(boardStatus);
            }
            else if ((gameSettings.gameMode == "Hard")&&(playerColor == -1)){
              movement = expertAI(boardStatus);
            }
            else{movement = await getMovement();}
            console.log(`Clicked at coordinates: (${movement[0]}, ${movement[1]})`);
            validStatus = isValid(movement);
            console.log(playerColor); // Corrected typo in console.log
            validMovement = movement;
          }

          Update(validMovement,playerColor);
          displayGoboard();
          winStatus = checkWin();

          playerColor = -playerColor;
        }

          // Update the game-result element when the game ends
          const gameResult = document.getElementById("game-result");
          if (winStatus === 1) {
            gameResult.innerHTML = "Game Over! Black wins!";
          } else if (winStatus === -1) {
            gameResult.innerHTML = "Game Over! White wins!";
          }

      }
      // This part is the script of the game (Main structure)
    


      function isValid(movement) {
        let x = movement[0];
        let y = movement[1];

        if (boardStatus[x][y]!=0){
          return false;
        }
        else{
          return true;
        }
      }
      //This function checks if the move is valid
    
      function displayGoboard() {
        const board = document.getElementById("board");
        // Remove existing pieces from the board
        const existingPieces = document.querySelectorAll(".black, .white");
        existingPieces.forEach((piece) => board.removeChild(piece));
        
        // Iterate through the boardStatus and add pieces to the board
        for (let i = 0; i < 19; i++) {
          for (let j = 0; j < 19; j++) {
            if (boardStatus[i][j] !== 0) {
              const piece = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              piece.setAttribute("r", "4.2");
              piece.setAttribute("cx", (i - 9) * 10);
              piece.setAttribute("cy", (j - 9) * 10); 
              console.log(boardStatus[i][j]);
              piece.setAttribute("fill", boardStatus[i][j] == 1 ? "black" : "white");
              board.appendChild(piece);
            }
          }
        }
      }
      //This function displays the board based on the boardStatus


      function Update(movement,playerColor) {
        let x = movement[0];
        let y = movement[1];
        boardStatus[x][y] = playerColor;
        console.log(`Placed piece at position (${x}, ${y})`);
/********************************************************************/
        if(gameSettings.gameMode == "PvP")  
          ws.send(JSON.stringify(  {type: 'DropPiece', boardStatus: boardStatus}  ));

/********************************************************************/
      }
      //This function updates the boardStatus according to new move
    
      function checkWin() {
        const len = boardStatus.length;
        
        function checkLine(x, y, dx, dy) {
          const player = boardStatus[x][y];
          if (player === 0) return false;
          for (let i = 1; i < 5; i++) {
            const newX = x + dx * i;
            const newY = y + dy * i;
            if (
              newX < 0 || newX >= len ||
              newY < 0 || newY >= len ||
              boardStatus[newX][newY] !== player
              ) {
                return false;
              }
            }
            return true;
        }
        for (let i = 0; i < len; i++) {
          for (let j = 0; j < len; j++) {
            if (
              checkLine(i, j, 1, 0) ||
              checkLine(i, j, 0, 1) ||
              checkLine(i, j, 1, 1) ||
              checkLine(i, j, 1, -1)
              ) {
                return boardStatus[i][j];
              }
            }
          }
          return 0;
        }

    
      play();
    

      function getMovement() {
        return new Promise((resolve) => {
          const board = document.getElementById("board");
          
          const tempPiece = createTempPiece();
          board.appendChild(tempPiece);

          board.addEventListener("mousemove", function (event) {
            
            

            const rect = board.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            newx = Math.floor(x/30);
            newy = Math.floor(y/30);

            if (boardStatus[newx][newy]== 0){
            tempPiece.setAttribute("cx", (newx-9)*10);
            tempPiece.setAttribute("cy", (newy-9)*10);
            tempPiece.setAttribute("fill", playerColor === 1 ? "black" : "white");
            }
            
            console.log("Mouse position on board: " + newx + "," + newy);

          });

          function onClick(event) {
            const rect = board.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            console.log("Clicked on board at: " + x + "," + y);
            board.removeEventListener("click", onClick);
            board.removeChild(tempPiece);

            newx = Math.floor(x/30);
            newy = Math.floor(y/30);
            resolve([newx,newy]);
          }
    
          board.addEventListener("click", onClick);
        });

        function createTempPiece() {
          const piece = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          piece.setAttribute("r", "4.2");
          piece.style.opacity = "0.3";
          piece.setAttribute("cx", -1000);
          piece.setAttribute("cy", -1000);
          return piece;
        }
      }
      // This function will get the position of the mouse on the board, as well as the position to drop the piece


    


      


    </script>
    


</body>

